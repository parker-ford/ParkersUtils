#include "Packages/com.parker.utilities/Runtime/Shaders/Includes/Complex.cginc"
#include "Packages/com.parker.utilities/Runtime/Shaders/Includes/ShaderUtils.cginc"

#pragma kernel CS_FFT
#pragma kernel CS_DFT
#pragma kernel CS_InverseScale
#pragma kernel CS_FrequencyShift
#pragma kernel CS_SymmetricScale
#pragma kernel CS_LogarithmicScale
#pragma kernel CS_ConvertToMagnitude
#pragma kernel CS_ConvertToPhase

#pragma multi_compile _ FFT_SIZE_16 FFT_SIZE_64 FFT_SIZE_128 FFT_SIZE_256 FFT_SIZE_512 FFT_SIZE_1024
#if defined(FFT_SIZE_1024)
#define SIZE 1024
#define LOG_SIZE 10
#elif defined(FFT_SIZE_512)
#define SIZE 512
#define LOG_SIZE 9
#elif defined(FFT_SIZE_256)
#define SIZE 256
#define LOG_SIZE 8
#elif defined(FFT_SIZE_128)
#define SIZE 128
#define LOG_SIZE 7
#elif defined(FFT_SIZE_64)
#define SIZE 64
#define LOG_SIZE 6
#elif defined(FFT_SIZE_16)
#define SIZE 16
#define LOG_SIZE 4
#else
#define SIZE 64
#define LOG_SIZE 6
#endif

groupshared Complex fftGroupBuffer[2][SIZE];
groupshared Complex dftGroupBuffer[SIZE];

RWTexture2D<Complex> _Target;
bool _Direction;
bool _Inverse;

Complex DFT(uint threadIndex, Complex input){
    dftGroupBuffer[threadIndex] = input;
    GroupMemoryBarrierWithGroupSync();

    Complex fn = 0;
    for(uint k = 0; k < SIZE; k++){

        float theta = TWO_PI * float(threadIndex * k) / float(SIZE);
        Complex w = Complex(cos(theta), -sin(theta));
        if(_Inverse) w = ComplexConjugate(w);

        Complex fk = dftGroupBuffer[k];
        fn += ComplexMult(fk, w);
    }

    GroupMemoryBarrierWithGroupSync();
    return fn;
}

void ButterflyValues(uint step, uint index, out uint2 indices, out Complex twiddle) {
    uint b = SIZE >> (step + 1);
    uint w = b * (index / b);
    uint i = (w + index) % SIZE;
    sincos(-TWO_PI / SIZE * w, twiddle.y, twiddle.x);

    if(_Inverse) twiddle.y = -twiddle.y;
    indices = uint2(i, i + b);
}

Complex FFT(uint threadIndex, Complex input) {
    fftGroupBuffer[0][threadIndex] = input;
    GroupMemoryBarrierWithGroupSync();
    bool flag = false;

    [unroll]
    for (uint step = 0; step < LOG_SIZE; ++step) {
        uint2 inputsIndices;
        Complex twiddle;
        ButterflyValues(step, threadIndex, inputsIndices, twiddle);

        Complex v = fftGroupBuffer[flag][inputsIndices.y];
        fftGroupBuffer[!flag][threadIndex] = fftGroupBuffer[flag][inputsIndices.x] + ComplexMult(twiddle, v.xy);

        flag = !flag;
        GroupMemoryBarrierWithGroupSync();
    }

    return fftGroupBuffer[flag][threadIndex];
}

[numthreads(SIZE, 1, 1)]
void CS_DFT (uint3 id : SV_DispatchThreadID)
{
    uint threadIndex = id.x;
    uint2 targetIndex = _Direction ? id.yx : id.xy;
    _Target[targetIndex] = DFT(threadIndex, _Target[targetIndex]);
}

[numthreads(SIZE, 1, 1)]
void CS_FFT (uint3 id : SV_DispatchThreadID)
{
    uint threadIndex = id.x;
    uint2 targetIndex = _Direction ? id.yx : id.xy;
    _Target[targetIndex] = FFT(threadIndex, _Target[targetIndex]);
}

[numthreads(8,8,1)]
void CS_InverseScale(uint3 id : SV_DispatchThreadID) 
{
    _Target[id.xy] /= SIZE * SIZE;
}

[numthreads(8,8,1)]
void CS_SymmetricScale(uint3 id : SV_DispatchThreadID)
{
    _Target[id.xy] /= sqrt(SIZE * SIZE);
}

[numthreads(8,8,1)]
void CS_LogarithmicScale(uint3 id : SV_DispatchThreadID)
{
    _Target[id.xy] = log(1.0 + _Target[id.xy]) / log(1000); // Large enough, avoids calculating max value 
}

[numthreads(8,8,1)]
void CS_FrequencyShift(uint3 id : SV_DispatchThreadID) 
{
    float shift = (id.x + id.y) & 1 ? -1 : 1;
    _Target[id.xy] *= shift;
}

[numthreads(8,8,1)]
void CS_ConvertToMagnitude(uint3 id : SV_DispatchThreadID)
{
    float magnitude = ComplexMagnitude(_Target[id.xy]);
    _Target[id.xy] = magnitude;
}

[numthreads(8,8,1)]
void CS_ConvertToPhase(uint3 id : SV_DispatchThreadID)
{
    float phase = ComplexPhase(_Target[id.xy]);
    _Target[id.xy] = phase;
}
