#include "Packages/com.parker.utilities/Runtime/Shaders/Includes/Complex.cginc"
#include "Packages/com.parker.utilities/Runtime/Shaders/Includes/ShaderUtils.cginc"

#pragma kernel CS_FFT
#pragma kernel CS_DFT

#pragma multi_compile _ FFT_SIZE_16 FFT_SIZE_64 FFT_SIZE_128 FFT_SIZE_256 FFT_SIZE_512 FFT_SIZE_1024
#if defined(FFT_SIZE_1024)
#define SIZE 1024
#define LOG_SIZE 10
#elif defined(FFT_SIZE_512)
#define SIZE 512
#define LOG_SIZE 9
#elif defined(FFT_SIZE_256)
#define SIZE 256
#define LOG_SIZE 8
#elif defined(FFT_SIZE_128)
#define SIZE 128
#define LOG_SIZE 7
#elif defined(FFT_SIZE_64)
#define SIZE 64
#define LOG_SIZE 6
#elif defined(FFT_SIZE_16)
#define SIZE 16
#define LOG_SIZE 4
#else
#define SIZE 64
#define LOG_SIZE 6
#endif

// groupshared float4 fftGroupBuffer[2][SIZE];
groupshared Complex dftGroupBuffer[SIZE];

RWTexture2D<Complex> _Target;
bool _Direction;
bool _Inverse;

float2 DFT(uint threadIndex, Complex input){
    dftGroupBuffer[threadIndex] = input;
    GroupMemoryBarrierWithGroupSync();

    Complex fn = 0;
    for(uint k = 0; k < SIZE; k++){

        float theta = TWO_PI * float(threadIndex * k) / float(SIZE);
        Complex w = Complex(cos(theta), -sin(theta));

        Complex fk = dftGroupBuffer[k];
        fn += ComplexMult(fk, w);
    }

    GroupMemoryBarrierWithGroupSync();
    return fn;
}

[numthreads(SIZE, 1, 1)]
void CS_DFT (uint3 id : SV_DispatchThreadID)
{
    uint threadIndex = id.x;
    uint2 targetIndex = _Direction ? id.yx : id.xy;
    _Target[targetIndex] = DFT(threadIndex, _Target[targetIndex]);
}

[numthreads(SIZE, 1, 1)]
void CS_FFT (uint3 id : SV_DispatchThreadID)
{
    
}
